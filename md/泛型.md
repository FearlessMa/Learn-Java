# 泛型

* jdk1.5之后java中追加了泛型，主要是为了解决ClassCastEx'ception的问题,在进行对象的向下转型时永远都可能存在安全隐患。java希望可以通过泛型慢慢解决掉此类问题。

## 泛型问题引出

* 描述x,y坐标的处理类，并允许保存三类数据。
    * 整型数据：x=10,y=20
    * 浮点型数据： x=10.1,y=20.9
    * 字符串型：x=东经20度,y=北纬30度
* 设计Point类需要考虑具体的x,y属性的类型,要求可以保存以上三种数据。
    * Object类定义
        * 整型数据： 基本数据 -> 经过包装 Integer类对象 -> 自动向上转型为Object
        * 浮点型数据： 基本数据 -> 经过包装 Double类对象 -> 自动向上转型为Object
        * 字符串型数据：  String类对象 -> 自动向上转型为Object

```java
class Point {
    private Object x;
    private Object y;

    public void setX(Object x) {
        this.x = x;
    }

    public void setY(Object y) {
        this.y = y;
    }

    public Object getX() {
        return this.x;
    }

    public Object getY() {
        return this.y;
    }
}

public class JavaDemo12 {
    public static void main(String[] args) {
        Point p = new Point();
        p.setX(10);// 自动装箱
        p.setY(20);
        // 获取x，y
        int x = (Integer) p.getX(); //拆箱，向下转型获取数据
        int y = (Integer) p.getY();
        System.out.println("x=" + x + "、y=" + y);
        // x=10、y=20
    }
}
```

* 以上可以解决，是因为Object可以接收所有的数据类型。但是会出现安全隐患。

```java
p.setX(10);// 自动装箱
p.setY("北纬30度");
```
<strong>编译的时候不会出现问题，程序执行时候就会出现ClassCastException,所以会存在安全隐患</strong>安全隐患存在的根本是因为Object可以接收所有类型。

## 泛型的基本定义

* 如果想要避免ClassCastException，最好避免掉对象的强制类型转换。
* <strong color='red'>泛型的本质，类中的属性或方法的参数与返回值可以由对象实例化时动态决定。</strong>此时在类定义时，就需要明确的占位符(泛型标记)

```java
class Point<T> { //T是Type的简写,可以定义多个泛型
    private T x;
    private T y;

    public void setX(T x) {
        this.x = x;
    }

    public void setY(T y) {
        this.y = y;
    }

    public T getX() {
        return this.x;
    }

    public T getY() {
        return this.y;
    }
}
```

* 此时Point中的x,y数据类型并不确定，而是由外部决定。
* 由于泛型是属于jdk1.5之后的,以前没有使用泛型，为了兼容以前，所以不设置泛型类型，默认是Object作为类型。但是编译会提示警告。
* <strong>泛型在定义完成后可以在实例化对象的时候,可以进行泛型类型的设置,一旦设置之后，使用泛型的类内部使用的类型就与当前对象直接绑定了</strong>

```java
public static void main(String[] args) {
    Point<Integer> p = new Point<Integer>();
    p.setX(10);// 自动装箱
    p.setY(20);
    // 获取x，y
    int x = p.getX();
    int y = p.getY();
    System.out.println("x=" + x + "、y=" + y);
    // x=10、y=20
}
```

* 泛型的类型设置，只使用当前p实例对象。这样编译时就可以发现类型错误，避免安全隐患

* 注意
    * 泛型之中只允许设置引用类型,如果要操作基本类型，必须使用包装类。
    * 从jdk1.7开始泛型实例化，可以简化为Point<Integer> p = new Point<>();
